//<?php
/**
 * This file is part of byrokrat/accounting.
 *
 * byrokrat/accounting is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * byrokrat/accounting is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with byrokrat/accounting. If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2016 Hannes Forsgård
 */

namespace byrokrat\accounting\Sie4;

/**
 * Grammar for generating a SIE version 4 compliant parser using scato/phpeg
 *
 * @see "bin/build_sie_parser" To rebuild the parser
 */
grammar SieGrammar extends SieDependencyManager
{
    start FILE = EMPTY_LINE* FLAGGA_POST IDENTIFICATION_POST* ACCOUNT_PLAN_POST* BALANCE_POST*;

    FLAGGA_POST = ROW_START 'FLAGGA' ^ flag:BOOLEAN ROW_END {
        $this->getContainer()->setAttribute('FLAGGA', $flag);
    };

    // Posts for identification and meta-data

    // TODO Släng till alla poster som finns här så att jag kan få bättre resolv på integration tests...
        // ska ta en main container och skriva alla attribute till den
        // Parser::getContainer()->addAttribute('bkod', 1234566) osv...
        // samma kontainer ska sedan användas även i VerificationHelper ...

    IDENTIFICATION_POST = ADRESS_POST
        / OMFATTN_POST
        / SIETYP_POST
        / VALUTA_POST
        / VOID_ROW;

    ADRESS_POST = ROW_START 'ADRESS' ^ contact:STRING address:STRING location:STRING phone:STRING ROW_END {
        $this->onAdress((string)$contact, (string)$address, (string)$location, (string)$phone);
    };

    OMFATTN_POST = ROW_START 'OMFATTN' ^ date:DATE ROW_END {
        $this->getContainer()->setAttribute('OMFATTN', $date);
    };

    SIETYP_POST = ROW_START 'SIETYP' ^ ver:INT ROW_END {
        $this->onSietyp($ver);
    };

    VALUTA_POST = ROW_START 'VALUTA' ^ currency:STRING ROW_END {
        $this->onValuta($currency);
    };

    // Posts defining the account plan

    ACCOUNT_PLAN_POST = KONTO_POST
        / KTYP_POST
        / ENHET_POST
        / SRU_POST
        / DIM_POST
        / UNDERDIM_POST
        / OBJEKT_POST
        / VOID_ROW;

    KONTO_POST = ROW_START 'KONTO' ^ number:INT description:STRING ROW_END {
        $this->onKonto($number, $description);
    };

    KTYP_POST = ROW_START 'KTYP' ^ number:INT type:STRING ROW_END {
        $this->onKtyp($number, $type);
    };

    ENHET_POST = ROW_START 'ENHET' ^ account:INT unit:STRING ROW_END {
        $this->onEnhet($account, $unit);
    };

    SRU_POST = ROW_START 'SRU' ^ account:INT sru:INT ROW_END {
        $this->onSru($account, $sru);
    };

    DIM_POST = ROW_START 'DIM' ^ dim:INT desc:STRING ROW_END {
        $this->onDim($dim, $desc);
    };

    UNDERDIM_POST = ROW_START 'UNDERDIM' ^ dim:INT desc:STRING superdim:INT ROW_END {
        $this->onUnderdim($dim, $desc, $superdim);
    };

    OBJEKT_POST = ROW_START 'OBJEKT' ^ dim:INT obj:INT desc:STRING ROW_END {
        $this->onObjekt($dim, $obj, $desc);
    };

    // Posts defining balances and verifications

    BALANCE_POST = IB_POST
        / OIB_POST
        / VER_POST
        / VOID_ROW;

    IB_POST = ROW_START 'IB' ^ year:INT account:ACCOUNT balance:AMOUNT quantity:INT? ROW_END {
        $this->onIb($year, $account, $balance, $quantity ?: 0);
    };

    OIB_POST = ROW_START 'OIB' ^ year:INT account:ACCOUNT objects:OBJECT_LIST balance:AMOUNT quantity:INT? ROW_END {
        $this->onOib($year, $account, $objects, $balance, $quantity ?: 0);
    };

    // TODO also implement #RTRANS and #BTRANS
    TRANS_POST = ROW_START 'TRANS' ^ account:ACCOUNT objects:OBJECT_LIST amount:AMOUNT date:DATE? desc:STRING? quantity:INT? signature:STRING? ROW_END {
        // TODO hur fungerar det egentligen med optional arguments här??
        return $this->onTrans($account, $objects, $amount, $date, $desc, $quantity, $signature);
    };

    VER_POST = ROW_START 'VER' ^ series:STRING number:INT date:DATE desc:STRING? regdate:DATE? sign:STRING? ROW_END SUBROW_START trans:(TRANS_POST / VOID_ROW)* SUBROW_END {
        // TODO hur fungerar det egentligen med optional arguments här??
        return $this->onVer($series, $number, $date, $desc, $regdate, $sign, $trans);
    };

    //
    // Unknown posts
    //

    VOID_ROW = UNKNOWN_POST / EMPTY_LINE;

    UNKNOWN_POST = ROW_START !VALID_LABEL label:VALID_CHARS ^ vars:STRING* EOL {
        $this->onUnknown($label, $vars);
    };

    VALID_LABEL = 'ADRESS'
        / 'BKOD'
        / 'DIM'
        / 'ENHET'
        / 'FLAGGA'
        / 'FNAMN'
        / 'FNR'
        / 'FORMAT'
        / 'FTYP'
        / 'GEN'
        / 'IB'
        / 'KONTO'
        / 'KPTYP'
        / 'KTYP'
        / 'OBJEKT'
        / 'OIB'
        / 'OMFATTN'
        / 'ORGNR'
        / 'OUB'
        / 'PBUDGET'
        / 'PROGRAM'
        / 'PROSA'
        / 'PSALDO'
        / 'RAR'
        / 'RES'
        / 'SIETYP'
        / 'SRU'
        / 'TAXAR'
        / 'TRANS'
        / 'RTRANS'
        / 'BTRANS'
        / 'UB'
        / 'UNDERDIM'
        / 'VALUTA'
        / 'VER';

    //
    // Row utilities
    //

    SUBROW_START = _ '{' _ EOL;

    SUBROW_END = _ '}' _ EOL;

    ROW_START = _ '#';

    ROW_END = STRING* EOL;

    //
    // The type system
    //

    // Date

    DATE = _ date:(RAW_DATE / QUOTED_DATE) _ {
        return $date;
    };

    QUOTED_DATE = '"' date:RAW_DATE '"' {
            return $date;
    };

    RAW_DATE = year:([0-9] [0-9] [0-9] [0-9]) month:([0-9] [0-9])? day:([0-9] [0-9])? {
        return new \DateTimeImmutable(
            implode($year)
            . (implode((array)$month) ?: '01')
            . (implode((array)$day) ?: '01')
        );
    };

    // Amount

    AMOUNT = _ amount:(RAW_AMOUNT / QUOTED_AMOUNT) _ {
        return $amount;
    };

    QUOTED_AMOUNT = '"' amount:RAW_AMOUNT '"' {
        return $amount;
    };

    RAW_AMOUNT = negation:"-"? units:[0-9]+ "."? subunits:([0-9]? [0-9]?) {
        return $this->createMoney($negation.implode($units).'.'.implode($subunits));
    };

    // Account

    ACCOUNT = number:INT {
        return $this->getAccount($number);
    };

    // Object

    OBJECT = super:INT number:INT {
        return $this->getObject($super, $number);
    };

    OBJECT_LIST = _ '{' objects:OBJECT* '}' _ {
        return $objects;
    };

    // Integer

    INT = _ int:(RAW_INT / QUOTED_INT) _ {
        return $int;
    };

    QUOTED_INT = '"' int:RAW_INT '"' {
        return $int;
    };

    RAW_INT = negation:"-"? units:[0-9]+ {
        return intval($negation.implode($units));
    };

    // Boolean

    BOOLEAN = _ bool:(RAW_BOOLEAN / QUOTED_BOOLEAN) _ {
        return $bool;
    };

    QUOTED_BOOLEAN = '"' bool:RAW_BOOLEAN '"' {
        return $bool;
    };

    RAW_BOOLEAN = bool:[01] {
        return !!$bool;
    };

    // String

    STRING = _ string:(VALID_CHARS / QUOTED_STRING) _ {
        return $string;
    };

    QUOTED_STRING = '"' string:(ESCAPED_QUOTE / ' ' / VALID_CHARS)+ '"' {
        return implode($string);
    };

    VALID_CHARS = chars:[a-zA-Z0-9!#$%&'()*+,-.\/:;<=>?@\[\\\]^_`{|}~]+ {
        return implode($chars);
    };

    ESCAPED_QUOTE = '\"' {
        return '"';
    };

    //
    // Miscellaneous
    //

    EMPTY_LINE = _ EOL;

    EOL = "\r"? "\n";

    _ = (" " / "\t")*;
}
