//<?php
/**
 * This file is part of byrokrat/accounting.
 *
 * byrokrat/accounting is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * byrokrat/accounting is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with byrokrat/accounting. If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2016 Hannes Forsgård
 */

namespace byrokrat\accounting\Sie4;

/**
 * Grammar for generating a SIE version 4 compliant parser using scato/phpeg
 *
 * @example "vendor/bin/phpeg generate src/Sie4/Grammar.peg" To rebuild the parser (from project root)
 * @see     Parser for a concrete parser implementation
 */
grammar Grammar
{
    // TODO check out the phpeg documentation on error reporting!

    start FILE = EMPTY_LINE* FLAGGA_POST IDENTIFICATION_POST* ACCOUNT_PLAN_POST* BALANCE_POST*;

    FLAGGA_POST = ROW_START 'FLAGGA' flag:BOOLEAN ROW_END {
        $this->onFlagga($flag);
    };

    // Posts for identification and meta-data

    IDENTIFICATION_POST = ADRESS_POST
        / OMFATTN_POST
        / SIETYP_POST
        / VALUTA_POST
        / IGNORED_ROW;

    ADRESS_POST = ROW_START 'ADRESS' contact:STRING address:STRING location:STRING phone:STRING ROW_END {
        $this->onAdress((string)$contact, (string)$address, (string)$location, (string)$phone);
    };

    OMFATTN_POST = ROW_START 'OMFATTN' date:DATE ROW_END {
        $this->onOmfattn($date);
    };

    SIETYP_POST = ROW_START 'SIETYP' ver:INTEGER ROW_END {
        $this->onSietyp($ver);
    };

    VALUTA_POST = ROW_START 'VALUTA' currency:STRING ROW_END {
        $this->onValuta($currency);
    };

    // Posts defining the account plan

    ACCOUNT_PLAN_POST = KONTO_POST
        / KTYP_POST
        / ENHET_POST
        / SRU_POST
        / DIM_POST
        / UNDERDIM_POST
        / OBJEKT_POST
        / IGNORED_ROW;

    KONTO_POST = ROW_START 'KONTO' number:INTEGER description:STRING ROW_END {
        $this->onKonto($number, $description);
    };

    KTYP_POST = ROW_START 'KTYP' number:INTEGER type:STRING ROW_END {
        $this->onKtyp($number, $type);
    };

    ENHET_POST = ROW_START 'ENHET' account:INTEGER unit:STRING ROW_END {
        $this->onEnhet($account, $unit);
    };

    SRU_POST = ROW_START 'SRU' account:INTEGER sru:INTEGER ROW_END {
        $this->onSru($account, $sru);
    };

    DIM_POST = ROW_START 'DIM' dim:INTEGER name:STRING ROW_END {
        // TODO implement #DIM
    };

    UNDERDIM_POST = ROW_START 'UNDERDIM' dim:INTEGER name:STRING superdim:INTEGER ROW_END {
        // TODO implement #UNDERDIM
    };

    OBJEKT_POST = ROW_START 'OBJEKT' dim:INTEGER obj:INTEGER name:STRING ROW_END {
        // TODO implement #OBJEKT
    };

    // Posts defining balances and verifications

    BALANCE_POST = IB_POST
        / VER_POST
        / IGNORED_ROW;

    IB_POST = ROW_START 'IB' year:INTEGER account:ACCOUNT balance:AMOUNT quantity:INTEGER? ROW_END {
        $this->onIb($year, $account, $balance, $quantity ?: 0);
    };

    TRANS_POST = ROW_START 'TRANS' ROW_END {
        // TODO implement #TRANS kontonr {objektlista} belopp transdat transtext kvantitet sign (some optional...)
        // TODO also implement #RTRANS and #BTRANS
        // TODO create transaction object
    };

    VER_POST = ver:VER_ROW SUBENTRY_START trans:(TRANS_POST / IGNORED_ROW)* SUBENTRY_END {
        // TODO hur säkerställa att IGNORED_ROW inte returnerar någonting??
            // returnerar void så det borde gå att trimma alla void från arrayen $trans
        $ver->addTransaction(...$trans);
    };

    VER_ROW = ROW_START 'VER' ROW_END {
        // TODO implement #VER serie vernr verdatum vertext regdatum sign (some optional...)
        // TODO create verification object
    };

    //
    // Unknown posts
    //

    IGNORED_ROW = UNKNOWN_POST / EMPTY_LINE;

    UNKNOWN_POST = ROW_START !VALID_LABEL label:VALID_CHARS vars:STRING+ EOL {
        $this->onUnknown($label, $vars);
    };

    VALID_LABEL = 'ADRESS'
        / 'BKOD'
        / 'DIM'
        / 'ENHET'
        / 'FLAGGA'
        / 'FNAMN'
        / 'FNR'
        / 'FORMAT'
        / 'FTYP'
        / 'GEN'
        / 'IB'
        / 'KONTO'
        / 'KPTYP'
        / 'KTYP'
        / 'OBJEKT'
        / 'OIB'
        / 'OMFATTN'
        / 'ORGNR'
        / 'OUB'
        / 'PBUDGET'
        / 'PROGRAM'
        / 'PROSA'
        / 'PSALDO'
        / 'RAR'
        / 'RES'
        / 'SIETYP'
        / 'SRU'
        / 'TAXAR'
        / 'TRANS'
        / 'RTRANS'
        / 'BTRANS'
        / 'UB'
        / 'UNDERDIM'
        / 'VALUTA'
        / 'VER';

    //
    // Row utilities
    //

    SUBENTRY_START = _ '{' _ EOL;

    SUBENTRY_END = _ '}' _ EOL;

    ROW_START = _ '#';

    ROW_END = STRING* EOL;

    //
    // The type system
    //

    // Date

    DATE = _ date:(RAW_DATE / QUOTED_DATE) _ {
        return $date;
    };

    QUOTED_DATE = '"' date:RAW_DATE '"' {
            return $date;
    };

    RAW_DATE = year:([0-9] [0-9] [0-9] [0-9]) month:([0-9] [0-9])? day:([0-9] [0-9])? {
        return new \DateTime(
            implode($year)
            . (implode((array)$month) ?: '01')
            . (implode((array)$day) ?: '01')
        );
    };

    // Amount

    AMOUNT = _ amount:(RAW_AMOUNT / QUOTED_AMOUNT) _ {
        return $amount;
    };

    QUOTED_AMOUNT = '"' amount:RAW_AMOUNT '"' {
        return $amount;
    };

    RAW_AMOUNT = negation:"-"? units:[0-9]+ "."? subunits:([0-9]? [0-9]?) {
        return $this->createMoney($negation.implode($units).'.'.implode($subunits));
    };

    // Account

    ACCOUNT = number:INTEGER {
        return $this->getAccount($number);
    };

    // Integer

    INTEGER = _ int:(RAW_INTEGER / QUOTED_INTEGER) _ {
        return $int;
    };

    QUOTED_INTEGER = '"' int:RAW_INTEGER '"' {
        return $int;
    };

    RAW_INTEGER = negation:"-"? units:[0-9]+ {
        return intval($negation.implode($units));
    };

    // Boolean

    BOOLEAN = _ bool:(RAW_BOOLEAN / QUOTED_BOOLEAN) _ {
        return $bool;
    };

    QUOTED_BOOLEAN = '"' bool:RAW_BOOLEAN '"' {
        return $bool;
    };

    RAW_BOOLEAN = bool:[01] {
        return !!$bool;
    };

    // String

    STRING = _ string:(VALID_CHARS / QUOTED_STRING) _ {
        return $string;
    };

    QUOTED_STRING = '"' string:(ESCAPED_QUOTE / ' ' / VALID_CHARS)+ '"' {
        return implode($string);
    };

    VALID_CHARS = chars:[a-zA-Z0-9!#$%&'()*+,-.\/:;<=>?@\[\\\]^_`{|}~]+ {
        return implode($chars);
    };

    ESCAPED_QUOTE = '\"' {
        return '"';
    };

    //
    // Miscellaneous
    //

    EMPTY_LINE = _ EOL;

    EOL = "\r"? "\n";

    _ = (" " / "\t")*;
}
