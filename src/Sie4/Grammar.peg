//<?php
/**
 * This file is part of byrokrat/accounting.
 *
 * byrokrat/accounting is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * byrokrat/accounting is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with byrokrat/accounting. If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2016 Hannes Forsgård
 */

namespace byrokrat\accounting\Sie4;

use byrokrat\accounting\Verification;
use byrokrat\accounting\Transaction;

/**
 * Grammar for generating a SIE version 4 compliant parser using scato/phpeg
 *
 * @example "vendor/bin/phpeg generate src/Sie4/Grammar.peg" To rebuild the parser (from project root)
 * @see     Parser for a concrete parser implementation
 */
grammar Grammar
{
    start FILE = EMPTY_LINE* FLAGGA_POST IDENTIFICATION_POST* ACCOUNT_PLAN_POST* BALANCE_POST*;

    FLAGGA_POST = ROW_START 'FLAGGA' ^ flag:BOOLEAN ROW_END {
        $this->onFlagga($flag);
    };

    // Posts for identification and meta-data

    IDENTIFICATION_POST = ADRESS_POST
        / OMFATTN_POST
        / SIETYP_POST
        / VALUTA_POST
        / IGNORED_ROW;

    ADRESS_POST = ROW_START 'ADRESS' ^ contact:STRING address:STRING location:STRING phone:STRING ROW_END {
        $this->onAdress((string)$contact, (string)$address, (string)$location, (string)$phone);
    };

    OMFATTN_POST = ROW_START 'OMFATTN' ^ date:DATE ROW_END {
        $this->onOmfattn($date);
    };

    SIETYP_POST = ROW_START 'SIETYP' ^ ver:INTEGER ROW_END {
        $this->onSietyp($ver);
    };

    VALUTA_POST = ROW_START 'VALUTA' ^ currency:STRING ROW_END {
        $this->onValuta($currency);
    };

    // Posts defining the account plan

    ACCOUNT_PLAN_POST = KONTO_POST
        / KTYP_POST
        / ENHET_POST
        / SRU_POST
        / DIM_POST
        / UNDERDIM_POST
        / OBJEKT_POST
        / IGNORED_ROW;

    KONTO_POST = ROW_START 'KONTO' ^ number:INTEGER description:STRING ROW_END {
        $this->onKonto($number, $description);
    };

    KTYP_POST = ROW_START 'KTYP' ^ number:INTEGER type:STRING ROW_END {
        $this->onKtyp($number, $type);
    };

    ENHET_POST = ROW_START 'ENHET' ^ account:INTEGER unit:STRING ROW_END {
        $this->onEnhet($account, $unit);
    };

    SRU_POST = ROW_START 'SRU' ^ account:INTEGER sru:INTEGER ROW_END {
        $this->onSru($account, $sru);
    };

    DIM_POST = ROW_START 'DIM' ^ dim:INTEGER desc:STRING ROW_END {
        $this->onDim($dim, $desc);
    };

    UNDERDIM_POST = ROW_START 'UNDERDIM' ^ dim:INTEGER desc:STRING superdim:INTEGER ROW_END {
        $this->onUnderdim($dim, $desc, $superdim);
    };

    OBJEKT_POST = ROW_START 'OBJEKT' ^ dim:INTEGER obj:INTEGER desc:STRING ROW_END {
        $this->onObjekt($dim, $obj, $desc);
    };

    // Posts defining balances and verifications

    BALANCE_POST = IB_POST
        / OIB_POST
        / VER_POST
        / IGNORED_ROW;

    IB_POST = ROW_START 'IB' ^ year:INTEGER account:ACCOUNT balance:AMOUNT quantity:INTEGER? ROW_END {
        $this->onIb($year, $account, $balance, $quantity ?: 0);
    };

    OIB_POST = ROW_START 'OIB' ^ year:INTEGER account:ACCOUNT objects:OBJECT_LIST balance:AMOUNT quantity:INTEGER? ROW_END {
        $this->onOib($year, $account, $objects, $balance, $quantity ?: 0);
    };

    // TODO also implement #RTRANS and #BTRANS
    TRANS_POST = ROW_START 'TRANS' ^ account:ACCOUNT objects:OBJECT_LIST amount:AMOUNT date:DATE? desc:STRING? quantity:INTEGER? signature:STRING? ROW_END {
        // TODO lyft ut till helper $this->createTransaction(...), eller onTrans ?

        $transaction = new Transaction($account, $amount, $quantity ?: 0, ...$objects);

        if ($date) {
            $transaction->setDate($date);
        }

        if ($desc) {
            $transaction->setDescription($desc);
        }

        if ($signature) {
            $transaction->setSignature($signature);
        }

        return $transaction;
    };

    VER_POST = ver:VER_ROW SUBENTRY_START trans:(TRANS_POST / IGNORED_ROW)* SUBENTRY_END {
        // TODO lyft ut till helper $this->onVer(...)

        foreach ($trans as $transaction) {
            if (!$transaction instanceof Transaction) {
                continue;
            }

            if (!$transaction->hasDate()) {
                $transaction->setDate($ver->getDate());
            }

            $ver->addTransaction($transaction);
        }

        // TODO kontrolera att verifikation är balanserad...
    };

    VER_ROW = ROW_START 'VER' ^ series:STRING number:INTEGER date:DATE desc:STRING? regdate:DATE? sign:STRING? ROW_END {
        // TODO Ver ska inte hålla koll på serie
            // om jag flyttar upp allt detta till VER_POST så kan jag i helper hålla koll på om där finns olika serier...

        $verification = (new Verification)->setNumber($number)->setDate($date);

        if ($desc) {
            $verification->setDescription($desc);
        }

        if ($regdate) {
            $verification->setRegistrationDate($regdate);
        }

        if ($sign) {
            $verification->setSignature($sign);
        }

        return $verification;
    };

    //
    // Unknown posts
    //

    IGNORED_ROW = UNKNOWN_POST / EMPTY_LINE;

    UNKNOWN_POST = ROW_START !VALID_LABEL label:VALID_CHARS ^ vars:STRING* EOL {
        $this->onUnknown($label, $vars);
    };

    VALID_LABEL = 'ADRESS'
        / 'BKOD'
        / 'DIM'
        / 'ENHET'
        / 'FLAGGA'
        / 'FNAMN'
        / 'FNR'
        / 'FORMAT'
        / 'FTYP'
        / 'GEN'
        / 'IB'
        / 'KONTO'
        / 'KPTYP'
        / 'KTYP'
        / 'OBJEKT'
        / 'OIB'
        / 'OMFATTN'
        / 'ORGNR'
        / 'OUB'
        / 'PBUDGET'
        / 'PROGRAM'
        / 'PROSA'
        / 'PSALDO'
        / 'RAR'
        / 'RES'
        / 'SIETYP'
        / 'SRU'
        / 'TAXAR'
        / 'TRANS'
        / 'RTRANS'
        / 'BTRANS'
        / 'UB'
        / 'UNDERDIM'
        / 'VALUTA'
        / 'VER';

    //
    // Row utilities
    //

    SUBENTRY_START = _ '{' _ EOL;

    SUBENTRY_END = _ '}' _ EOL;

    ROW_START = _ '#';

    ROW_END = STRING* EOL;

    //
    // The type system
    //

    // Date

    DATE = _ date:(RAW_DATE / QUOTED_DATE) _ {
        return $date;
    };

    QUOTED_DATE = '"' date:RAW_DATE '"' {
            return $date;
    };

    RAW_DATE = year:([0-9] [0-9] [0-9] [0-9]) month:([0-9] [0-9])? day:([0-9] [0-9])? {
        return new \DateTimeImmutable(
            implode($year)
            . (implode((array)$month) ?: '01')
            . (implode((array)$day) ?: '01')
        );
    };

    // Amount

    AMOUNT = _ amount:(RAW_AMOUNT / QUOTED_AMOUNT) _ {
        return $amount;
    };

    QUOTED_AMOUNT = '"' amount:RAW_AMOUNT '"' {
        return $amount;
    };

    RAW_AMOUNT = negation:"-"? units:[0-9]+ "."? subunits:([0-9]? [0-9]?) {
        return $this->createMoney($negation.implode($units).'.'.implode($subunits));
    };

    // Account

    ACCOUNT = number:INTEGER {
        return $this->getAccount($number);
    };

    // Object

    OBJECT = super:INTEGER number:INTEGER {
        return $this->getObject($super, $number);
    };

    OBJECT_LIST = _ '{' objects:OBJECT* '}' _ {
        return $objects;
    };

    // Integer

    INTEGER = _ int:(RAW_INTEGER / QUOTED_INTEGER) _ {
        return $int;
    };

    QUOTED_INTEGER = '"' int:RAW_INTEGER '"' {
        return $int;
    };

    RAW_INTEGER = negation:"-"? units:[0-9]+ {
        return intval($negation.implode($units));
    };

    // Boolean

    BOOLEAN = _ bool:(RAW_BOOLEAN / QUOTED_BOOLEAN) _ {
        return $bool;
    };

    QUOTED_BOOLEAN = '"' bool:RAW_BOOLEAN '"' {
        return $bool;
    };

    RAW_BOOLEAN = bool:[01] {
        return !!$bool;
    };

    // String

    STRING = _ string:(VALID_CHARS / QUOTED_STRING) _ {
        return $string;
    };

    QUOTED_STRING = '"' string:(ESCAPED_QUOTE / ' ' / VALID_CHARS)+ '"' {
        return implode($string);
    };

    VALID_CHARS = chars:[a-zA-Z0-9!#$%&'()*+,-.\/:;<=>?@\[\\\]^_`{|}~]+ {
        return implode($chars);
    };

    ESCAPED_QUOTE = '\"' {
        return '"';
    };

    //
    // Miscellaneous
    //

    EMPTY_LINE = _ EOL;

    EOL = "\r"? "\n";

    _ = (" " / "\t")*;
}
