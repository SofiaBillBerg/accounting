//<?php
/**
 * This file is part of byrokrat/accounting.
 *
 * byrokrat/accounting is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * byrokrat/accounting is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with byrokrat/accounting. If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2016 Hannes Forsg책rd
 */

namespace byrokrat\accounting\Sie4;

/**
 * Grammar for generating a SIE version 4 compliant parser using scato/phpeg
 *
 * @example "vendor/bin/phpeg generate src/Sie4/Grammar.peg" To rebuild the parser (from project root)
 * @see     Parser for a concrete parser implementation
 */
grammar Grammar
{
    start FILE = POST*;

    POST = FLAG_POST
        / SIE_VERSION_POST
        / CURRENCY_POST
        / INCOMING_BALANCE_POST
        / MAGNITUDE_DATE_POST
        / ADDRESS_POST
        / UNKNOWN_ROW
        / EMPTY_LINE;

    UNKNOWN_ROW = ROW_START label:[a-zA-Z]+ vars:STRING+ EOL {
        return $this->onUnknown(implode($label), $vars);
    };

    FLAG_POST = ROW_START 'FLAGGA' flag:BOOLEAN ROW_END {
        return $this->onFlag($flag);
    };

    SIE_VERSION_POST = ROW_START 'SIETYP' ver:INTEGER ROW_END {
        return $this->onSieVersion($ver);
    };

    ADDRESS_POST = ROW_START 'ADRESS' contact:STRING address:STRING location:STRING phone:STRING ROW_END {
        return $this->onAddress((string)$contact, (string)$address, (string)$location, (string)$phone);
    };

    CURRENCY_POST = ROW_START 'VALUTA' currency:STRING ROW_END {
        return $this->onCurrency($currency);
    };

    INCOMING_BALANCE_POST = ROW_START 'IB' year:INTEGER account:STRING balance:AMOUNT quantity:INTEGER? ROW_END {
        // TODO account ska vara en egen type med alla finesser definierade i Helper...
        return $this->onIncomingBalance(
            $year,
            $account,
            $balance,
            $quantity ?: 0
        );
    };

    MAGNITUDE_DATE_POST = ROW_START 'OMFATTN' date:DATE ROW_END {
        $this->onMagnitudeDate($date);
    };

    VERIFICATION_ROW = ROW_START ROW_END {
        // TODO create verification object
        return 'created verification';
    };

    TRANSACTION_ROW = ROW_START ROW_END {
        // TODO create transaction object...
        return 'created transaction';
    };

    VERIFICATION_POST = ver:VERIFICATION_ROW SUBENTRY_START trans:(TRANSACTION_ROW / UNKNOWN_ROW)* SUBENTRY_END {
        // TODO hur s채kerst채lla att UNKNOWN_ROW inte returnerar n책gonting??
        return $ver->addTransaction(...$trans);
    };

    SUBENTRY_START = _ '{' _ EOL;

    SUBENTRY_END = _ '}' _ EOL;


    ROW_START = _ '#';

    ROW_END = STRING* EOL;

    //
    // The type system
    //

    // Date

    DATE = _ date:(RAW_DATE / QUOTED_DATE) _ {
        return $date;
    };

    QUOTED_DATE = '"' date:RAW_DATE '"' {
            return $date;
    };

    RAW_DATE = year:([0-9] [0-9] [0-9] [0-9]) month:([0-9] [0-9])? day:([0-9] [0-9])? {
        return new \DateTime(
            implode($year)
            . (implode((array)$month) ?: '01')
            . (implode((array)$day) ?: '01')
        );
    };

    // Amount

    AMOUNT = _ amount:(RAW_AMOUNT / QUOTED_AMOUNT) _ {
        return $amount;
    };

    QUOTED_AMOUNT = '"' amount:RAW_AMOUNT '"' {
        return $amount;
    };

    RAW_AMOUNT = negation:"-"? units:[0-9]+ "."? subunits:([0-9]? [0-9]?) {
        return $this->onAmount($negation.implode($units).'.'.implode($subunits));
    };

    // Integer

    INTEGER = _ int:(RAW_INTEGER / QUOTED_INTEGER) _ {
        return $int;
    };

    QUOTED_INTEGER = '"' int:RAW_INTEGER '"' {
        return $int;
    };

    RAW_INTEGER = negation:"-"? units:[0-9]+ {
        return intval($negation.implode($units));
    };

    // Boolean

    BOOLEAN = _ bool:(RAW_BOOLEAN / QUOTED_BOOLEAN) _ {
        return $bool;
    };

    QUOTED_BOOLEAN = '"' bool:RAW_BOOLEAN '"' {
        return $bool;
    };

    RAW_BOOLEAN = bool:[01] {
        return !!$bool;
    };

    // String

    STRING = _ string:(VALID_CHARS / QUOTED_STRING) _ {
        return $string;
    };

    QUOTED_STRING = '"' string:(ESCAPED_QUOTE / ' ' / VALID_CHARS)+ '"' {
        return implode($string);
    };

    VALID_CHARS = chars:[a-zA-Z0-9!#$%&'()*+,-.\/:;<=>?@\[\\\]^_`{|}~]+ {
        return implode($chars);
    };

    ESCAPED_QUOTE = '\"' {
        return '"';
    };

    //
    // Miscellaneous
    //

    EMPTY_LINE = _ EOL;

    EOL = "\r"? "\n";

    _ = (" " / "\t")*;
}
